# V0.3 — "Remembers"

## Purpose

buddy has memory. It recalls past conversations, learns user preferences, and maintains working context across a session.

## Capabilities

- **Short-term working memory:** A structured scratchpad (key-value + free-form notes) that persists within a conversation. The LLM can read/write it via `memory_read` and `memory_write` skills. Cleared when the conversation ends.
- **Long-term memory:** Configurable vector store backend (trait-based, like providers). Ships with two implementations:
  - SQLite + simple embedding (local, zero-config)
  - Optional: connect to an external store (Qdrant, ChromaDB) for users who want it
- **Automatic context retrieval:** On each user message, buddy searches long-term memory for relevant past interactions and injects them as system context. The user can see what was recalled (transparency).
- **`remember` skill:** Explicitly save a fact or preference to long-term memory
- **`recall` skill:** Explicitly search memory for something
- Embedding generation via the configured LLM provider (if it supports embeddings) or a separate lightweight model
- **User approval flow:** Before `write_file` or any mutating skill executes, the UI shows what will happen and waits for explicit user confirmation. Configurable: always-ask, ask-once-per-skill, or trust (per-skill).

## Key Architectural Decisions

- The `VectorStore` trait is deliberately minimal: `store(id, embedding, metadata)`, `search(embedding, limit) -> Vec<Result>`. Don't over-abstract — two implementations are enough to validate the boundary.
- Working memory is a skill, not a special subsystem. The LLM decides when to use it. This avoids complex heuristics about what to remember.
- Long-term memory retrieval is automatic but visible. The user can disable it per-conversation or globally. No hidden context injection.
- The approval flow is implemented as middleware in the skill execution pipeline, not bolted onto individual skills. Every skill declares its `PermissionLevel` (read-only, mutating, network). The middleware enforces the user's policy.

## Intentionally Not Included

- No multi-agent or task delegation
- No skill-creator framework
- No Telegram/WhatsApp
- No cross-conversation "projects" or workspaces

## Sets Up V0.4 By

The approval flow and permission model are prerequisites for running buddy on non-localhost interfaces. Memory makes buddy useful enough that accessing it from a phone (Telegram) becomes compelling.
